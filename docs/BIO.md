# BIO 示例项目

该项目展示了使用阻塞 I/O (BIO) 模型实现的简单客户端和服务器端应用程序。服务器监听特定端口，等待客户端连接。客户端连接后，服务器会向客户端发送一条消息。

## 项目结构

```
Learn-Java
├── src
│   └── main
│       └── java
│           └── example
│               ├── bio
│               │   ├── BioServer.java  # 服务器端代码
│               │   └── BioClient.java  # 客户端代码
└── pom.xml
```

## 运行说明

1. 启动 `BioServer` 服务器：
   ```bash
   mvn exec:java -Dexec.mainClass="example.bio.BioServer"
   ```

2. 启动 `BioClient` 客户端：
   ```bash
   mvn exec:java -Dexec.mainClass="example.bio.BioClient"
   ```

## BIO 原理

BIO (Blocking I/O) 是 Java 早期的网络 I/O 模型。BIO 模型在每个连接上使用独立线程处理 I/O 操作，使用阻塞模式执行输入和输出。这意味着每当服务器调用 `accept()`、`read()` 或 `write()` 方法时，它都会阻塞当前线程，直到操作完成。

### BIO 的处理流程
1. **服务器端启动并监听端口**：创建 `ServerSocket` 并调用 `accept()` 方法等待客户端连接，该方法是阻塞的，直到有客户端请求连接。
2. **客户端连接服务器**：客户端创建 `Socket` 并连接服务器端。连接建立后，服务器通过 `OutputStream` 向客户端发送数据。
3. **数据传输**：服务器使用 `OutputStream` 向客户端发送消息，客户端通过 `InputStream` 读取消息。
4. **关闭连接**：数据传输完成后，服务器端关闭与客户端的连接。

### BIO 的缺点

1. **资源浪费**：每个客户端连接都需要一个独立的线程来处理，这会导致大量的线程创建和管理开销，尤其在并发连接数较大时，系统资源消耗巨大。
2. **性能瓶颈**：在 I/O 操作等待过程中，线程会被阻塞，不能有效利用 CPU 资源。对于高并发场景，大量线程的阻塞和上下文切换会导致性能急剧下降。
3. **不适合高并发**：BIO 模型对每个连接创建一个线程，在高并发情况下会迅速消耗系统资源，导致线程数量过多，系统无法响应更多的请求。

## 适用场景

BIO 模型适合连接数较少、业务处理逻辑简单的应用场景，如早期的 Web 服务器、小规模应用程序等。在现代高并发网络应用中，BIO 已被更高效的 NIO 和 AIO 模型所取代。

---

通过这个示例项目，可以直观地看到 BIO 的处理流程及其在高并发场景下的局限性。